<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta http-equiv="x-ua-compatible" content="IE=9" >

<title>BIOS560R Spring 2014 - LAB Lists and Data Frames</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>




</head>

<body>
<h1>BIOS560R Spring 2014 - LAB Lists and Data Frames</h1>

<p>Pittard <a href="mailto:wsp@emory.edu">wsp@emory.edu</a></p>

<hr/>

<h2>Working with lists</h2>

<p>Practice 1.0) R returns lists from many of its stat functions</p>

<pre><code class="r">data(mtcars)  # Load mtcars into the environment

mylm <- lm(mpg ~ wt, data = mtcars)

print(mylm)

typeof(mylm)

str(mylm)

names(mylm)

mylm$effects

my.summary &lt;- function(x) {
    return.list <- list()  # Declare the list

    return.list$mean <- mean(x)
    return.list$sd <- sd(x)
    return.list$var <- var(x)

    return(return.list)
}
my.summary(1:10)

names(my.summary(1:10))

my.summary(1:10)$var
</code></pre>

<hr/>

<p>1.1) strsplit returns a list whose elements conain character strings</p>

<pre><code class="r">mystring <- &quot;This is a test&quot;

mys <- strsplit(mystring, &quot; &quot;)

str(mys)

mys

mys[[1]][1]

mys[[1]][1:2]

unlist(mys)

</code></pre>

<hr/>

<p>1.2) Lists are similar to structures in other languages such as C or C++</p>

<pre><code class="r">employee1 <- list(id_number = 1, age = 22, salary = 12000.21)

employee2 <- list(id_number = 2, age = 32, salary = 13000)

employee3 <- list(id_number = 3, age = 40, salary = 90000)

emp_database <- list(employee1=employee1, employee2=employee2, employee3=employee3)

str(emp_database)

emp_database$employee1$id 

emp_database[1:2]       # Pull out the first two elements of emp_database (which are also lists)

sapply(emp_database, function(x) x)    # Print back list element values

# We can turn this list of lists into a data frame by using this &#39;recipe&#39;

my.df <- do.call(rbind, emp_database)

</code></pre>

<hr/>

<p>1.3) Let&#39;s start a family !</p>

<pre><code class="r">
family1 <- list(husband = &quot;Fred&quot;, wife = &quot;Wilma&quot;, numofchildren = 3, agesofkids = c(8, 
    11, 14))

length(family1)  # Has 4 elements

family1

str(family1)

</code></pre>

<hr/>

<p>1.4) Indexing into lists can be done via element name or element number</p>

<pre><code class="r">names(family1)

family1$agesofkids  # If the list elements have names then use &#39;$&#39; to access the element

family1$agesofkids[1:2]

# If the list elements have no names then you have to use numeric indexing

family1 <- list(&quot;Fred&quot;, &quot;Wilma&quot;, 3, c(8, 11, 14))

family1

family1[1]  # So we get back the list element number as well as the element&#39;s value

family1[[1]]  # Oh so the double bracket is more specific - we get just the element value

family1[[4]][1:2]  # With respect to the 4th element show the first two values of the vector

</code></pre>

<hr/>

<p>1.5) You can &ldquo;neutralize&rdquo; a list by using the unlist function</p>

<pre><code class="r">unlist(family1)

as.numeric(unlist(family1))

# You can add elements to a named list by using the $ symbol

family1 <- list(husband = &quot;Fred&quot;, wife = &quot;Wilma&quot;, numofchildren = 3, agesofkids = c(8, 
    11, 14))

family1$numofpets <- 2

family1

# You can add elements to a list using a numeric index

family1 <- list(husband = &quot;Fred&quot;, wife = &quot;Wilma&quot;, numofchildren = 3, agesofkids = c(8, 
    11, 14))

family1[5] <- 2

family1

# You can delete elements by setting them to a value of NULL

family1 <- list(husband = &quot;Fred&quot;, wife = &quot;Wilma&quot;, numofchildren = 3, agesofkids = c(8, 
    11, 14))

family1$wife <- NULL

family1

# OR USE ELEMENT NUMBER IF YOU WISH

family1 <- list(husband = &quot;Fred&quot;, wife = &quot;Wilma&quot;, numofchildren = 3, agesofkids = c(8, 
    11, 14))

family1[2] <- NULL

</code></pre>

<hr/>

<p>1.6) List elements can be processed using sapply and lapply.</p>

<pre><code class="r">family1 <- list(husband = &quot;Fred&quot;, wife = &quot;Wilma&quot;, numofchildren = 3, agesofkids = c(8, 
    11, 14))

sapply(family1, class)

# This provides a pleasant and efficient alternative to using a for loop:

for (ii in 1:length(family1)) {
    cat(names(family1)[ii], &quot; : &quot;, class(family1[[ii]]), &quot;\n&quot;)
}

# 

lapply(family1, class)  # Very similar to sapply but returns a list

lapply(family1, mean)

# Here we write a function that checks if the element is numeric or not

my.func &lt;- function(x) {
    if (class(x) == &quot;numeric&quot;) {
        return(mean(x))
    }
}

lapply(Family, my.func)

</code></pre>

<hr/>

<h2>Working with Data frames</h2>

<p>2.0) Most data frames are &ldquo;given&rdquo; to us when we read in .CSV files using read.table. We can also build a data frame out of pre-existing vectors or even lists.</p>

<pre><code class="r">names <- c(&quot;P1&quot;, &quot;P2&quot;, &quot;P3&quot;, &quot;P4&quot;, &quot;P5&quot;)

temp <- c(98.2, 101.3, 97.2, 100.2, 98.5)

pulse <- c(66, 72, 83, 85, 90)

gender <- c(&quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;)

my_df <- data.frame(names, temp, pulse, gender)  # Much more flexible

my_df

# We can access columns of a data frame as if it were a list

plot(my_df$pulse ~ my_df$temp, main = &quot;Pulse Rate&quot;, xlab = &quot;Patient&quot;, ylab = &quot;BPM&quot;)

# We can also access columns of a data frame as if it were a matrix

colMeans(my_df[,2:3])

rowMeans(my_df[,2:3])

</code></pre>

<hr/>

<p>2.1) There are a number of functions we can use to get information about data frames</p>

<pre><code class="r">rownames(mtcars)

colnames(mtcars)

head(mtcars, 10)

rownames(mtcars) <- paste(&quot;car&quot;, 1:32, sep = &quot;_&quot;)  # Name the rows according to a pattern

summary(mtcars)  # A generic way to get information on a data frame

</code></pre>

<hr/>

<p>2.2) The bracket notation works on data frames which should not be a surprise since a data frame
has characteristics of a vector, matrix, and list. </p>

<pre><code class="r">
mtcars[, -11]

mtcars[, -3:-5]  # Print all columns except for columns 3 through 5

mtcars[, c(-3, -5)]  # Print all columns except for colums 3 AND 5

# We can also pass logical expressions into the bracket notation

mtcars[mtcars$mpg &gt;= 30, ]

mtcars[mtcars$mpg &gt;= 30, 2:6]

mtcars[mtcars$mpg &gt;= 30 &amp; mtcars$cyl &lt; 6, ]

mtcars[mtcars$am == 0, ]

nrow(mtcars[mtcars$am == 0, ])

nrow(mtcars[mtcars$am == 1, ])

# we can even do dynamic calculations within the bracket notation

mtcars[mtcars$mpg &gt; mean(mtcars$mpg), ]

mtcars[mtcars$mpg &gt; quantile(mtcars$mpg)[4], ]

</code></pre>

<hr/>

<p>2.3) It is a good habit to identify the potential factors within your data.</p>

<pre><code class="r">str(mtcars)

sapply(mtcars, function(x) length(unique(x)))

summary(mtcars$am)  # Treats am as a numeric entity

mtcars$am <- factor(mtcars$am, levels = c(0, 1), labels = c(&quot;Auto&quot;, &quot;Man&quot;))

# Now we get something sensible.

summary(mtcars$am)

</code></pre>

<hr/>

<p>Problem 2.4) We can bind rows and columns to a data frame</p>

<pre><code class="r">data(mtcars)  # reload the mtcars data frame

mpgrate <- cut(mtcars$mpg,breaks = quantile(mtcars$mpg),labels=c("horrible","Bad","Good","Great"),include.lowest=T)

mtcars$mpgrate  <- mpgrate

</code></pre>

<hr/>

<p>2.5) How do we handle missing values within data frames ?</p>

<pre><code class="r">url <- &quot;http://homepages.wmich.edu/~hgv7680/data/SAS/hs0.csv&quot;

data1 <- read.table(url, header = F, sep = &quot;,&quot;)

names(data1) <- c(&quot;gender&quot;, &quot;id&quot;, &quot;race&quot;, &quot;ses&quot;, &quot;schtyp&quot;, &quot;prgtype&quot;, &quot;read&quot;, 
    &quot;write&quot;, &quot;math&quot;, &quot;science&quot;, &quot;socst&quot;)

head(data1, n = 3)

nrow(data1)

sum(complete.cases(data1))  # how many complete cases do we have ?

sum(!complete.cases(data1))  # how many incomplete cases do we have ?

data1[!complete.cases(data1), ]

</code></pre>

<hr/>

<p>2.6) Reading tables from the Internet></p>
<pre><code class="r">
library(XML)
url <- "http://en.wikipedia.org/wiki/World_population"
table.four <- readHTMLTable(url, which=4) 

head(table.four,4)

table.four <- table.four[,-4:-6]  # Eliminate the 4th-6th column
table.four

table.four$Population <- as.numeric(gsub(",","",table.four$Population))/100000 

# Give the columns new names

names(table.four) <- c("Rank","Country","Population")

# Plot the data
library(lattice)

xyplot(Population ~ Country,table.four,scales = list(x = c(rot=60)),
       type="h",main="Most Densely Populated Countries")

</code></pre>

<p>2.7) Reading tables from the Internet. Note that you can influence how R interprets the column formats as the file
is being read. This assumes that you have studied the data in advance so you know what the incoming formats are. If you
don't convert the formats as you are reading them then you can always convert afterwards.</p>
<pre><code class="r">
classes <- c("integer","character","FormattedNumber","character",
             "Percent","character")
             
poptable <- readHTMLTable(url,which=4,colClasses=classes,
                          stringsAsFactors=F)

str(poptable)

</code></pre>

<p>2.8) Read in the this .csv file to create a data frame  
<pre><code class="r">
http://steviep42.bitbucket.org/bios545r_2016/SUPP.DIR/msleep_ggplot2.csv

How many rows and columns does it have ?

How many complete cases does it have ?

How many rows does it contain that have at least one missing value ? 

What are the possible factors in this data frame ? 

What is the average sleep_total across all "vore" types ?

Change the row names of this dataframe to be of the form "Animal_1", "Animal_2", and so on

Create a factor out of the fivenum summary for the sleep_total variable. (Look for help on the
fivenum function). Use this to create a four interval factor with labels of your choosing.
(e.g. Q1, Q2, Q3, Q4) Attach this factor as a column to the existing data frame.

</code></pre>


</code></pre>

<p>3.0) Chicago Crime Data</p>

<pre><code class="r">
url <- &quot;http://steviep42.bitbucket.org/YOUTUBE.DIR/chi_crimes.csv&quot;

download.file(url, &quot;chi_crimes.csv&quot;)

chi <- read.table(&quot;chi_crimes.csv&quot;, header = T, sep = &quot;,&quot;)

names(chi)

sapply(chi, function(x) length(unique(x)))

chi$Date <- strptime(chi$Date, &quot;%m/%d/%Y %r&quot;)  # Change Dates from factor to a &#39;real&#39; Date

chi$month <- months(chi$Date)

chi$month <- factor(chi$month, levels = c(&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, 
    &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;), 
    ordered = TRUE)

# Okay how many crimes were committed in each Month of the year ?

plot(1:12, as.vector(table(chi$month)), type = &quot;n&quot;, xaxt = &quot;n&quot;, ylab = &quot;Alleged Crimes&quot;, 
    xlab = &quot;Month&quot;, main = &quot;Chicago Crimes in 2012 by Month&quot;, ylim = c(5000, 
        33000))

grid()

axis(1, at = 1:12, labels = as.character(sapply(levels(chi$month), function(x) substr(x, 
    1, 3))), cex.axis = 0.8)

points(1:12, as.vector(table(chi$month)), type = &quot;b&quot;, pch = 19, col = &quot;blue&quot;)

points(1:12, as.vector(table(chi$month, chi$Arrest)[, 2]), col = &quot;red&quot;, pch = 19, 
    type = &quot;b&quot;)

legend(5, 20000, c(&quot;Reported Crimes&quot;, &quot;Actual Arrests&quot;), fill = c(&quot;blue&quot;, &quot;red&quot;))

barplot(table(chi$Arrest, chi$month), col = c(&quot;blue&quot;, &quot;red&quot;), cex.names = 0.5, 
    main = &quot;Chicago: Reported Crimes vs. Actual Arrests&quot;)

legend(&quot;topright&quot;, c(&quot;Arrests&quot;), fill = &quot;red&quot;)


library(lattice)
barchart(table(chi$month, chi$ampm), stack = FALSE, auto.key = T, freq = F)

# Let&#39;s map the gambling activity - specifically the dice games

hold <- chi[chi$Primary.Type == &quot;GAMBLING&quot;, ]
hold <- chi[chi$Primary.Type == &quot;GAMBLING&quot; &amp; chi$Description != &quot;GAME/DICE&quot;, ]

# You will also need to do install.packages(&#39;googleVis&#39;)

library(googleVis)  # This is an addon package you must install

hold$LatLon = paste(hold$Latitude, hold$Longitude, sep = &quot;:&quot;)

hold$Tip <- paste(hold$Description, hold$Locate.Description, hold$Block, &quot;&lt;BR&gt;&quot;, 
    sep = &quot; &quot;)

chi.plot <- gvisMap(hold, &quot;LatLon&quot;, &quot;Tip&quot;)

plot(chi.plot)

</code></pre>

</body>

</html>

